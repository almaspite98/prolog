% From Alain Colmerauer: An Introduction to Prolog III,
% Communications of the ACM, 33(7), 69-90, 1990.

:- use_module(library(clpq), [{}/1]).

% ------------------------------------------------------------
% The original program
% ------------------------------------------------------------

% Rectangle 1 x Width is covered by distinct squares of size Ss.
filled_rectangle(Width, Ss) :-
  distinct_squares(Ss), { Width >= 1 }, 
  filled_hole([-1,Width,1], _, Ss, []).

% distinct_squares(Ss): All elements of Ss are distinct.
distinct_squares([]).
distinct_squares([S|Ss]) :-
  { S > 0 }, outof(Ss, S),
  distinct_squares(Ss).

outof([],     _).
outof([S|Ss], S0) :- { S =\= S0 }, outof(Ss, S0).

% filled_hole(L0, L, Ss0, Ss): Hole in line L0
% filled with squares Ss0-Ss (diff list) gives line L.
% Def: h(L): sum of lengths of vertical lines in L.
% Pre: All elements of L0 except the first >= 0.
% Post: All elems in L >=0, h(L0) = h(L).
filled_hole(L, L, Ss, Ss) :-
  L = [V|_], {V >= 0}.
filled_hole([V|HL], L, [S|Ss0], Ss) :-
  { V < 0 }, placed_square(S, HL, L1),
  filled_hole(L1, L2, Ss0, Ss1), { V1=V+S },
  filled_hole([V1,S|L2], L, Ss1, Ss).

% placed_square(S, HL, L): placing a square on
% HL horizontal line gives (vertical) line L.
% Pre: all elems in HL >=0
% Post: all in L except first >=0, h(L) = h(HL)-S.
placed_square(S, [H,V,H1|L], L1) :- { S > H, V=0, H2=H+H1 }, 
  placed_square(S, [H2|L], L1).
placed_square(S, [S,V|L], [X|L]) :- { X=V-S }.
placed_square(S, [H|L], [X,Y|L]) :- { S < H, X= -S, Y=H-S }.


% ------------------------------------------------------------
% An example to illustrate the first solution for N = 9
% ------------------------------------------------------------
/*
|------------------|-------------------|----------------------------|
|                  |                   |                            |
|                  |                   |                            |
|                  |                   |                            |
|      S9 = 9      |                   |                            |
|                  |      S8 = 10      |                            |
|                  |                   |                            |
|                  |                   |          S6 = 14           |
|                  |                   |                            |
|----------------|-|                   |                            |
|                |-|-----------|-------|                            |
|                |             |       |                            |
|                |             | S5=4  |                            |
|     S3 = 8     |    S4=7     |       |                            |
|                |             |-------|----------------------------|
|                |             |                                    |
|                |             |                                    |
|----------------|-------------|                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|                              |               S2 = 18              |
|                              |                                    |
|          S1 = 15             |                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|                              |                                    |
|------------------------------|------------------------------------|
( Note: S7 = 1)
*/
:- public filled_rectangle9_sol1/2, filled_rectangle9_sol1_bis/2.
% A minimal subset of the constraints generated by the above 
% program, able to find the first solution for N = 9.
filled_rectangle9_sol1(Width, Ss) :-
        Ss = [S1,S2,S3,S4,S5,S6,S7,S8,S9],
%       distinct_squares(Ss), {Width>=1},
        {S1+S2=Width},
%       {S1=<S2},               
        {S3+S4=S1},                      {S6>=S5+S8},  
        {S5+S6=S2},		         {S4+S7=S3},   
        {S2+S6=<1},		         {S9=S3+S7},   
        {S2+S5=S1+S4},		         {S8>=S7+S9},  
        {S7+S8=S4+S5},		         {S1+S3+S9>=1}.

% A variant of the above, replacing less-eq and greater-eq 
% by equality --- one more constraint can be eliminated.
filled_rectangle9_sol1_bis(Width, [S1,S2,S3,S4,S5,S6,S7,S8,S9]) :-
        {S1+S2=Width},
        {S3+S4=S1},
        {S5+S6=S2},
        {S2+S6=1},     %
%       {S2+S5=S1+S4}, %
        {S7+S8=S4+S5},
        {S6=S5+S8},    %
        {S4+S7=S3},    %
        {S9=S3+S7},
        {S8=S7+S9},    %
        {S1+S3+S9=1}.  %

% ------------------------------------------------------------
% A variant of the filled_rectangle predicate
% capable of building a trail and collecting constraints.
% ------------------------------------------------------------


% Rectangle 1 x Width is covered by
% distinct squares of size Ss.
% Execute this predicate according to the
% Opts option list:
%  *  eqsq --- squares of equal size are allowed
%  *  trail(?Trail) --- return in Trail a list of atoms
%           describing the choices made
%      The Trail will contain some of the following atoms:
%     
%       filled_hole:
%        nohl  -- clause 1 selected: first line segment non negative
%        hole  -- clause 2 selected: first line segment negative
%     
%       placed_square:
%        join  -- clause 1 selected: two horizontal segments joined
%        exct  -- clause 2 selected: the square covers exactly the first
%                 horizontal segment
%        part  -- clause 3 selected: the square covers the first
%                 horizontal segment only partially
%     
%   * collect(+Trail, ?Constraints) --- follow the execution
%           path described by Trail and return the list of
%           constraints posted on that path.
filled_rectangle(Width, Ss, Opts) :-
        (   member(collect(Trail,Cs), Opts) ->
            Mode = collect, L0 = Trail/Cs, L = []/[]
        ;   member(trail(Trail), Opts) ->
            Mode = trail, L0 = Trail, L = []
        ;   Mode = normal, L0 = [], L = []
        ),
        (   member(eqsq, Opts) -> EqSq = true
        ;   EqSq = false
        ),
        filled_rectangle(Width, Ss, Mode, EqSq, L0, L).

filled_rectangle(Width, Ss, Mode, EqSq) -->
        distinct_squares(Ss, Mode, EqSq),
        exec(Mode, [ Width >= 1]),
        (   {Mode = normal} -> { filled_hole([-1,Width,1], _, Ss, []) }
        ;   filled_hole([-1,Width,1], _, Ss, [], Mode)
        ).

% distinct_squares(Ss): All elements of Ss are
% positive and distinct. 
distinct_squares([], _, _) --> [].
distinct_squares([S|Ss], Mode, EqSq)  -->
        exec(Mode, [ S > 0 ]),
        (   {EqSq = true} -> {true}
        ;   outof(Ss, S, Mode)
        ),
        distinct_squares(Ss, Mode, EqSq).

outof([],      _, _) --> [].
outof([S|Ss], S0, Mode)  -->
        exec(Mode, [ S =\= S0 ]),
        outof(Ss, S0, Mode).

% filled_hole(L0, L, Ss0, Ss): Hole in line L0
% filled with squares Ss0-Ss (diff list) gives line L.
filled_hole(L, L, Ss, Ss, Mode) --> 
  {L = [V|_]}, exec(Mode, nohl, [ V >= 0 ]).
filled_hole([V|HL], L, [S|Ss0], Ss, Mode) --> 
  exec(Mode, hole, [ V < 0 ]), placed_square(S, HL, L1, Mode),
  filled_hole(L1, L2, Ss0, Ss1, Mode), exec(Mode, [ V1=V+S ]),
  filled_hole([V1,S|L2], L, Ss1, Ss, Mode).

% placed_square(S, HL, L): placing a square on
% HL horizontal line gives (vertical) line L.
placed_square(S, [H,V,H1|L], L1, Mode) --> 
  exec(Mode, join,  [ S > H, V=0, H2=H+H1 ]), 
  placed_square(S, [H2|L], L1, Mode).
placed_square(S, [H,V|L], [X|L], Mode) --> 
  exec(Mode, exct, [ H = S, X=V-S ]).
placed_square(S, [H|L], [X,Y|L], Mode) --> 
  exec(Mode, part, [ S < H, X= -S, Y=H-S ]).

% exec(Mode, Trail, Constraints, A0, A): Execute the
% Constraints list in Mode, adding Trail to the trail,
% if needed. The form of the accumulator pair A0-A depends
% on the execution mode:
%   normal  --- irrelevant
%   trail   --- a list of elements to be trailed
%   collect --- a pair of lists TrailElems/Constraints 
exec(normal, _, C) -->
  {constrain_list(C)}.
exec(trail, T, C) -->
  [T], {constrain_list(C)}.
exec(collect, T, C, Trl0/Cns0, Trl/Cns) :-
  Trl0 = [T|Trl], append(C, Cns, Cns0).

% A variant of exec/5 without trailing.
exec(normal, C) -->
  {constrain_list(C)}.
exec(trail, C) -->
  {constrain_list(C)}.
exec(collect, C, Trl/Cns0, Trl/Cns) :-
  append(C, Cns, Cns0).

% constrain_list(L): post all clpq constraints in list L.
constrain_list([]).
constrain_list([C|Cs]) :-
        {C}, constrain_list(Cs).

:- public test_rectangle/4, test_rectangle/5.

% Tests of the program, with timing
test_rectangle(N, MSec, Width, Ss) :-
	test_rectangle(N, MSec, Width, Ss, []).

test_rectangle(N, MSec, Width, Ss, Opts) :-
  length(Ss, N), N > 1, statistics(runtime, _),
  filled_rectangle(Width, Ss, Opts), 
  statistics(runtime, [_,MSec]).


:- public test_rectangle/3.

% Find solutions for N squares, using Opts, and output a clause
% containing all constraints generated for this solution.
test_rectangle(N, Opts, Clause) :-
  length(_Ss, N), N > 1, 
  filled_rectangle(_Width, _Ss, [trail(T)|Opts]), 
  length(Ss, N), N > 1, 
  filled_rectangle(Width, Ss, [collect(T,C0)|Opts]),
  name_variables(Width, Ss),
  transform_constraints(C0, C, []),
  list_to_round_list(C, C1),
  Clause = (filled_rectangle1(Width, Ss) :- C1).

% Instantiate the given variables  (Width and elements of Ss)
% with their names.
name_variables(Width, Ss) :-
        Width = '$VAR'("Width"),
        name_sq_variables(Ss, 1).

name_sq_variables([], _).
name_sq_variables([S|Ss], N) :-
        number_codes(N, NCs),
        S = '$VAR'([0'S|NCs]),  
        N1 is N+1,
        name_sq_variables(Ss, N1).

% transform_constraints(Cs, L0, L):
% L0-L is a simplified form of constraint list Cs.
transform_constraints([X=Y|Cs]) -->
        {X=Y}, !, transform_constraints(Cs).
transform_constraints([C0|Cs]) -->
        {simplify(C0, C)}, [{C}],
        transform_constraints(Cs).
transform_constraints([]) --> [].

% C is the simplified form of C0.
simplify(C0, C) :-
        C0 =.. [Op,L,R],
        pos_neg(L-R, Pos, [], Neg, []), 
        list_to_sum(Pos, P),
        list_to_sum(Neg, N),
        compose(P, Op, N, C), !.
simplify(C, C).

% C is the Prolog term describing the constraint L Op R.
compose(L, Op, R, C) :-
        number(L), \+ number(R), !, reversed_op(Op, OOp),
        compose(R, OOp, L, C).
compose(L, Op, R, C) :-
        C =.. [Op,L,R].

reversed_op(<, >).
reversed_op(=<, >=).
reversed_op(>, <).
reversed_op(>=, =<).
reversed_op(=, =).
reversed_op(=\=, =\=).

% pos_neg(Term, P0, P, N0, N): term Term is equivalent
% to (X1+...+Xn)-(Y1+...+Ym) where P0-P = [X1,...,Xn]
% and N0-N = [Y1,...,Yn].
pos_neg(A+B, P0, P, N0, N) :- !,
        pos_neg(A, P0, P1, N0, N1),
        pos_neg(B, P1, P, N1, N).
pos_neg(A-B, P0, P, N0, N) :- !,
        pos_neg(A, P0, P1, N0, N1),
        pos_neg(B, N1, N, P1, P).
pos_neg(-A, P0, P, N0, N) :- !,
        pos_neg(A, N0, N, P0, P).
pos_neg(0, P, P0, N, N0) :- !,
        P = P0, N = N0.
pos_neg(I, P, P0, N, N0) :-
        number(I), I < 0, !, I1 is -I,
        N = [I1|N0], P = P0.
pos_neg(A, [A|P0], P0, N0, N0).

 


% ------------------------------------------------------------
% Utilities
% ------------------------------------------------------------
        

% list_to_round_list(+L, ?RL) :- "Round" list RL contains
% the same elements as list L
% (i.e. if L = [A,B,...,X] then RL = (A,B,...,X) ).
list_to_round_list([X|L], RL) :-
        list_to_round_list(L, X, RL).

list_to_round_list([], X, X).
list_to_round_list([Y|L], X, (X,RL)) :-
        list_to_round_list(L, Y, RL).

% list_to_sum(L, S): S = X1+X2+...Xn, where L = [X1,X2,...,Xn]
list_to_sum([], 0).
list_to_sum([A|L], S) :-
        list_to_sum(L, A, S).

list_to_sum([], S, S).
list_to_sum([A|L], S0, S) :-
        list_to_sum(L, S0+A, S).

:- multifile portray/1.

portray(X) :-
	nonvar(X),
	X = '$VAR'(Chars),
	portray_var(Chars).

portray_var(Chars) :-
	atom(Chars), !, write(Chars).
portray_var(Chars) :-
	format('~s', [Chars]).



end_of_file.

% ------------------------------------------------------------
% Sample runs (Pentium III, 600 MHz)
% ------------------------------------------------------------

| ?- test_rectangle(N, MSec, Width, Ss).

N = 9,
Ss = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32],
MSec = 8090,
Width = 33/32 ? ;

N = 9,
Ss = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61],
MSec = 1000,
Width = 69/61 ? ;

N = 9,
Ss = [9/16,15/32,7/32,1/4,7/16,1/8,5/16,1/32,9/32],
MSec = 10840,
Width = 33/32 ? 

yes
| ?- test_rectangle(10, MSec, Width, Ss).

Ss = [45/104,15/26,1/4,19/104,2/13,11/26,7/104,3/26,33/104,7/26],
MSec = 35770,
Width = 105/104 ? ;

Ss = [55/94,30/47,39/94,8/47,11/94,15/94,17/47,23/94,2/47,19/94],
MSec = 4300,
Width = 115/94 ? ;

Ss = [27/55,6/11,13/55,1/5,3/55,8/55,5/11,2/55,17/55,3/11],
MSec = 14500,
Width = 57/55 ? 

yes
| ?- test_rectangle(_N, _MSec, Width, Ss, [eqsq]).

Ss = [1,1],
Width = 2 ? ;

Ss = [1/2,1,1/2],
Width = 3/2 ? ;

Ss = [1,1/2,1/2],
Width = 3/2 ? ;

Ss = [1,1,1],
Width = 3 ? ;

Ss = [1/3,1,1/3,1/3],
Width = 4/3 ? ;

Ss = [1/2,1/2,1/2,1/2],
Width = 1 ? ;

Ss = [2/3,1,1/3,1/3],
Width = 5/3 ? ;

Ss = [1,1/3,1/3,1/3],
Width = 4/3 ? ;

Ss = [1,2/3,1/3,1/3],
Width = 5/3 ? ;

Ss = [1/3,1/3,1,2/3],
Width = 5/3 ? ;

Ss = [1/2,1,1,1/2],
Width = 5/2 ? ;

Ss = [1,1/3,1/3,2/3],
Width = 5/3 ? ;

Ss = [1,1/2,1,1/2],
Width = 5/2 ? ;

Ss = [1,1,1/2,1/2],
Width = 5/2 ? ;

Ss = [1,1,1,1],
Width = 4 ? ;

Ss = [1/4,1,1/4,1/4,1/4],
Width = 5/4 ? 

yes
| ?- test_rectangle(4, [eqsq], _Clause), print(_Clause).    % Current single line output is not easy to read...
filled_rectangle1(Width, [S1,S2,S3,S4]) :-
        {S1>0},
        {S2>0},
        {S3>0},
        {S4>0},
        {Width>=1},
        {0<1},
        {S1<Width},
        {S1>0},
        {Width=S1+S2},
        {S2=<1},
        {S2>=S1},
        {S1<1},
        {S1=S3},
        {S2>=S1+S3},
        {S1+S3<1},
        {S3=S4},
        {S2>=S1+S3+S4},
        {S1+S3+S4>=1}.
yes
| ?- test_rectangle(9, [], _Clause), print(_Clause).    % Current single line output is not easy to read...
filled_rectangle1(Width, [S1,S2,S3,S4,S5,S6,S7,S8,S9]) :-
        {S1>0},
        {S2=\=S1},
        {S3=\=S1},
        {S4=\=S1},
        {S5=\=S1},
        {S6=\=S1},
        {S7=\=S1},
        {S8=\=S1},
        {S9=\=S1},
        {S2>0},
        {S3=\=S2},
        {S4=\=S2},
        {S5=\=S2},
        {S6=\=S2},
        {S7=\=S2},
        {S8=\=S2},
        {S9=\=S2},
        {S3>0},
        {S4=\=S3},
        {S5=\=S3},
        {S6=\=S3},
        {S7=\=S3},
        {S8=\=S3},
        {S9=\=S3},
        {S4>0},
        {S5=\=S4},
        {S6=\=S4},
        {S7=\=S4},
        {S8=\=S4},
        {S9=\=S4},
        {S5>0},
        {S6=\=S5},
        {S7=\=S5},
        {S8=\=S5},
        {S9=\=S5},
        {S6>0},
        {S7=\=S6},
        {S8=\=S6},
        {S9=\=S6},
        {S7>0},
        {S8=\=S7},
        {S9=\=S7},
        {S8>0},
        {S9=\=S8},
        {S9>0},
        {Width>=1},
        {0<1},
        {S1<Width},
        {S1>0},
        {Width=S1+S2},
        {S2=<1},
        {S2>=S1},
        {S1<1},
        {S3<S1},
        {S3>0},
        {S1=S3+S4},
        {S2<S1+S4},
        {S5<S2},
        {S5>0},
        {S2=S5+S6},
        {S2+S6=<1},
        {S6>=S5},
        {S2+S5>=S1+S4},
        {S4<S3},
        {S7<S4},
        {S7>0},
        {S8+S7>S4},
        {S2+S5=S1+S4},
        {S4+S5=S7+S8},
        {S6>=S5+S8},
        {S8>=S7},
        {S4+S7>=S3},
        {S1+S3<1},
        {S9>S3},
        {S4+S7=S3},
        {S3+S7=S9},
        {S8>=S7+S9},
        {S1+S3+S9>=1}.
yes
| ?- length(Ss, 9), filled_rectangle(Width, Ss, [trail(T)]), 
       (member(Ch, T), write(Ch), nl, fail; true).
hole
part    % S1 < Width
hole
exct	% only two squares at the bottom (Width = S1+S2)
nohl    % S2 =< 1
nohl    % S1 =< S2
hole    % 1 > S1
part    % S3 < S1
hole
exct	% only two squares above S1 (S1 = S3+S4)
hole    % S1+S4 > S2
part    % S5 < S2
hole
exct	% only two squares above S2 (S2 = S5+S6)
nohl    % S2+S6 =< 1
nohl    % S5 =< S6
nohl    % S1+S4 =< S2+S5
hole    % S3 >= S4
part    % S7 < S4
hole
join    % S8 > S4-S7, S1+S4 = S2+S5
exct	% only two squares above S4+S5 (S4+S5 = S7+S8)
nohl    % S5+S8 =< S6
nohl    % S7 =< S8
nohl    % S3 =< S4+S7 
hole    % 1 > S1+S3
join    % S9 > S3, S3 = S4+S7
exct	% only a single square above S3+S7 (S3+S7 = S9)
nohl    % S7+S9 =< S8 
nohl    % 1 =< S1+S3+S9 
T = [hole,part,hole,exct,nohl,nohl,hole,part,hole,exct|...],
Ss = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32],
Width = 33/32 ? 
yes
| ?- {S1 < Width,
     (Width = S1+S2),
     S2 =< 1,
     S1 =< S2,
     1 > S1,
     S3 < S1,
     (S1 = S3+S4),
     S1+S4 > S2,
     S5 < S2,
     (S2 = S5+S6),
     S2+S6 =< 1,
     S5 =< S6,
     S1+S4 =< S2+S5,
     S3 >= S4,
     S7 < S4,
     S8 > S4-S7, S1+S4 = S2+S5,
     (S4+S5 = S7+S8),
     S5+S8 =< S6,
     S7 =< S8,
     S3 =< S4+S7 ,
     1 > S1+S3,
     S9 > S3, S3 = S4+S7,
     (S3+S7 = S9),
     S7+S9 =< S8 ,
     1 =< S1+S3+S9}.
S1 = 15/32,
S2 = 9/16,
S3 = 1/4,
S4 = 7/32,
S5 = 1/8,
S6 = 7/16,
S7 = 1/32,
S8 = 5/16,
S9 = 9/32,
Width = 33/32 ? 
| ?- 
